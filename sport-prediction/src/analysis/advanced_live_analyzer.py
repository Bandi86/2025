#!/usr/bin/env python3
"""
üìä FEJLETT VAL√ìS IDEJ≈∞ ELEMZ≈ê
K√∂vetkez≈ë √≥r√°k meccseit elemzi r√©szletesen √©s fogad√°si javaslatokat ad.
"""

import json
import os
import sys
from datetime import datetime, timedelta
from typing import Dict, List, Optional

# Saj√°t modulok import√°l√°sa
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'tools'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'core'))

try:
    from live_match_predictor import LiveMatchPredictor, UpcomingMatch
    from realistic_betting_system import RealisticBettingSystem
except ImportError as e:
    print(f"‚ùå Import hiba: {e}")
    print("üí° Ellen≈ërizd hogy minden modul el√©rhet≈ë-e")
    exit(1)

class AdvancedLiveAnalyzer:
    """Fejlett val√≥s idej≈± elemz≈ë"""

    def __init__(self):
        self.predictor = LiveMatchPredictor()
        self.betting_system = RealisticBettingSystem()
        self.bankroll = 1000.0
        self.max_single_bet = 50.0
        self.min_edge = 0.05
        self.min_confidence = 0.3

    def analyze_next_hours(self, hours: int = 4) -> Dict:
        """K√∂vetkez≈ë √≥r√°k teljes elemz√©se"""
        print(f"üìä K√ñVETKEZ≈ê {hours} √ìRA TELJES ELEMZ√âSE")
        print("=" * 60)

        # Meccsek lek√©rdez√©se
        upcoming_matches = self.predictor.get_next_4_hours_matches()

        if not upcoming_matches:
            return {
                'status': 'no_matches',
                'message': f'Nincs meccs a k√∂vetkez≈ë {hours} √≥r√°ban',
                'matches': [],
                'betting_opportunities': []
            }

        # Predikci√≥k k√©sz√≠t√©se
        predictions = self.predictor.predict_upcoming_matches(upcoming_matches)

        # Fogad√°si lehet≈ës√©gek elemz√©se
        betting_opportunities = self._analyze_betting_opportunities(predictions)

        # R√©szletes jelent√©s
        detailed_report = self._generate_detailed_report(predictions, betting_opportunities)

        return {
            'status': 'success',
            'analyzed_at': datetime.now().isoformat(),
            'total_matches': len(predictions),
            'betting_opportunities': len(betting_opportunities),
            'predictions': predictions,
            'betting_suggestions': betting_opportunities,
            'detailed_report': detailed_report,
            'summary': self._generate_summary(predictions, betting_opportunities)
        }

    def _analyze_betting_opportunities(self, predictions: List[Dict]) -> List[Dict]:
        """Fogad√°si lehet≈ës√©gek elemz√©se"""
        print(f"\nüí∞ FOGAD√ÅSI LEHET≈êS√âGEK ELEMZ√âSE")
        print("=" * 40)

        opportunities = []

        for pred in predictions:
            # Szimul√°lt odds (val√≥di bookmaker odds helyett)
            simulated_odds = self._generate_simulated_odds(pred)

            # Value bet keres√©s
            value_bets = self._find_value_bets(pred, simulated_odds)

            if value_bets:
                for bet in value_bets:
                    opportunities.append({
                        'match': f"{pred['home_team']} vs {pred['away_team']}",
                        'kickoff_time': pred['kickoff_time'],
                        'competition': pred['competition'],
                        'bet_type': bet['type'],
                        'prediction_prob': bet['our_prob'],
                        'bookmaker_odds': bet['bookmaker_odds'],
                        'implied_prob': 1 / bet['bookmaker_odds'],
                        'edge': bet['edge'],
                        'suggested_stake': bet['stake'],
                        'potential_profit': bet['potential_profit'],
                        'confidence': pred['confidence'],
                        'recommendation': bet['recommendation']
                    })

        # Rendez√©s edge szerint
        opportunities.sort(key=lambda x: x['edge'], reverse=True)

        print(f"‚úÖ {len(opportunities)} √©rt√©kes fogad√°si lehet≈ës√©g tal√°lva")
        return opportunities

    def _generate_simulated_odds(self, prediction: Dict) -> Dict:
        """Szimul√°lt bookmaker odds gener√°l√°sa"""
        # Bookmaker margin hozz√°ad√°sa (5-8%)
        margin = 0.06

        # Tiszta val√≥sz√≠n≈±s√©gek
        clean_probs = {
            'home': prediction['prob_home'],
            'draw': prediction['prob_draw'],
            'away': prediction['prob_away']
        }

        # Margin hozz√°ad√°sa
        total_implied = sum(1/prob for prob in clean_probs.values())
        margin_multiplier = 1 + margin

        odds = {}
        for outcome, prob in clean_probs.items():
            fair_odd = 1 / prob
            bookmaker_odd = fair_odd / margin_multiplier
            odds[outcome] = round(bookmaker_odd, 2)

        return odds

    def _find_value_bets(self, prediction: Dict, bookmaker_odds: Dict) -> List[Dict]:
        """Value bet-ek keres√©se"""
        value_bets = []

        outcomes = {
            'home': prediction['prob_home'],
            'draw': prediction['prob_draw'],
            'away': prediction['prob_away']
        }

        for outcome, our_prob in outcomes.items():
            bookmaker_odd = bookmaker_odds[outcome]
            our_fair_odd = 1 / our_prob

            # Edge sz√°m√≠t√°sa
            edge = (our_fair_odd / bookmaker_odd) - 1

            if edge >= self.min_edge and prediction['confidence'] >= self.min_confidence:
                # Kelly stake sz√°m√≠t√°sa
                win_prob = our_prob
                kelly_fraction = (win_prob * (bookmaker_odd - 1) - (1 - win_prob)) / (bookmaker_odd - 1)
                kelly_stake = max(5, min(self.max_single_bet, kelly_fraction * self.bankroll * 0.5))

                # Aj√°nl√°s kateg√≥ri√°ja
                if edge > 0.15:
                    recommendation = "ER≈êS AJ√ÅNL√ÅS"
                elif edge > 0.10:
                    recommendation = "K√ñZEPES AJ√ÅNL√ÅS"
                else:
                    recommendation = "GYENGE AJ√ÅNL√ÅS"

                value_bets.append({
                    'type': outcome,
                    'our_prob': our_prob,
                    'bookmaker_odds': bookmaker_odd,
                    'edge': edge,
                    'stake': kelly_stake,
                    'potential_profit': kelly_stake * (bookmaker_odd - 1),
                    'recommendation': recommendation
                })

        return value_bets

    def _generate_detailed_report(self, predictions: List[Dict], opportunities: List[Dict]) -> Dict:
        """R√©szletes jelent√©s gener√°l√°sa"""
        report = {
            'match_analysis': [],
            'competition_breakdown': {},
            'time_distribution': {},
            'confidence_levels': {},
            'betting_summary': {
                'total_opportunities': len(opportunities),
                'total_potential_stake': sum(opp['suggested_stake'] for opp in opportunities),
                'total_potential_profit': sum(opp['potential_profit'] for opp in opportunities),
                'avg_edge': sum(opp['edge'] for opp in opportunities) / len(opportunities) if opportunities else 0
            }
        }

        # Meccs elemz√©sek
        for pred in predictions:
            match_analysis = {
                'match': f"{pred['home_team']} vs {pred['away_team']}",
                'kickoff': pred['kickoff_time'].strftime('%H:%M'),
                'competition': pred['competition'],
                'most_likely_outcome': self._get_most_likely_outcome(pred),
                'expected_goals': f"{pred['expected_goals']['home']:.1f} - {pred['expected_goals']['away']:.1f}",
                'confidence': f"{pred['confidence']:.1%}",
                'data_quality': f"Hazai: {pred['home_data_quality']}, Vend√©g: {pred['away_data_quality']}"
            }
            report['match_analysis'].append(match_analysis)

        # Bajnoks√°g szerinti bont√°s
        for pred in predictions:
            comp = pred['competition']
            if comp not in report['competition_breakdown']:
                report['competition_breakdown'][comp] = {'count': 0, 'matches': []}
            report['competition_breakdown'][comp]['count'] += 1
            report['competition_breakdown'][comp]['matches'].append(
                f"{pred['home_team']} vs {pred['away_team']}"
            )

        return report

    def _get_most_likely_outcome(self, prediction: Dict) -> str:
        """Legval√≥sz√≠n≈±bb kimenetel"""
        probs = {
            'Hazai gy≈ëzelem': prediction['prob_home'],
            'D√∂ntetlen': prediction['prob_draw'],
            'Vend√©g gy≈ëzelem': prediction['prob_away']
        }

        outcome, prob = max(probs.items(), key=lambda x: x[1])
        return f"{outcome} ({prob:.1%})"

    def _generate_summary(self, predictions: List[Dict], opportunities: List[Dict]) -> Dict:
        """√ñsszefoglal√≥ gener√°l√°sa"""
        if not predictions:
            return {'message': 'Nincs elemzend≈ë meccs'}

        # Statisztik√°k
        avg_confidence = sum(p['confidence'] for p in predictions) / len(predictions)
        high_confidence_matches = len([p for p in predictions if p['confidence'] > 0.7])

        # Legjobb lehet≈ës√©gek
        top_opportunities = sorted(opportunities, key=lambda x: x['edge'], reverse=True)[:3]

        return {
            'total_matches': len(predictions),
            'avg_confidence': f"{avg_confidence:.1%}",
            'high_confidence_matches': high_confidence_matches,
            'betting_opportunities': len(opportunities),
            'total_potential_stake': sum(opp['suggested_stake'] for opp in opportunities),
            'top_opportunities': [
                {
                    'match': opp['match'],
                    'bet_type': opp['bet_type'],
                    'edge': f"{opp['edge']:.1%}",
                    'stake': f"${opp['suggested_stake']:.0f}"
                }
                for opp in top_opportunities
            ],
            'competitions': list(set(p['competition'] for p in predictions))
        }

    def save_analysis_report(self, analysis_result: Dict, filename: Optional[str] = None) -> str:
        """Elemz√©s ment√©se f√°jlba"""
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"live_analysis_{timestamp}.json"

        output_dir = "data/live_analysis"
        os.makedirs(output_dir, exist_ok=True)

        filepath = os.path.join(output_dir, filename)

        # JSON serializable form√°tumra konvert√°l√°s
        serializable_result = self._make_json_serializable(analysis_result)

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(serializable_result, f, indent=2, ensure_ascii=False)

        print(f"üíæ Elemz√©s mentve: {filepath}")
        return filepath

    def _make_json_serializable(self, obj):
        """JSON serializable form√°tumra konvert√°l√°s"""
        if isinstance(obj, datetime):
            return obj.isoformat()
        elif isinstance(obj, dict):
            return {key: self._make_json_serializable(value) for key, value in obj.items()}
        elif isinstance(obj, list):
            return [self._make_json_serializable(item) for item in obj]
        else:
            return obj

    def print_betting_recommendations(self, opportunities: List[Dict]):
        """Fogad√°si javaslatok ki√≠r√°sa"""
        if not opportunities:
            print("‚ùå Nincs √©rt√©kes fogad√°si lehet≈ës√©g")
            return

        print(f"\nüíé TOP FOGAD√ÅSI JAVASLATOK")
        print("=" * 50)

        total_stake = 0

        for i, opp in enumerate(opportunities[:5], 1):  # Top 5
            print(f"\n{i}. {opp['match']}")
            print(f"   üïê {opp['kickoff_time'].strftime('%H:%M')} | üèÜ {opp['competition']}")
            print(f"   üéØ Tipp: {opp['bet_type'].upper()}")
            print(f"   üìä Saj√°t es√©ly: {opp['prediction_prob']:.1%}")
            print(f"   üé≤ Bookmaker odds: {opp['bookmaker_odds']:.2f}")
            print(f"   üìà Edge: {opp['edge']:.1%}")
            print(f"   üí∞ Javasolt t√©t: ${opp['suggested_stake']:.0f}")
            print(f"   üíµ V√°rhat√≥ profit: ${opp['potential_profit']:.0f}")
            print(f"   ‚≠ê {opp['recommendation']}")

            total_stake += opp['suggested_stake']

        print(f"\nüìã √ñSSZEGZ√âS:")
        print(f"   üí∞ √ñsszes javasolt t√©t: ${total_stake:.0f}")
        print(f"   üìä Bankroll ar√°ny: {(total_stake/self.bankroll)*100:.1f}%")

        if total_stake > self.bankroll * 0.1:
            print(f"   ‚ö†Ô∏è FIGYELEM: Magas kock√°zat!")
        else:
            print(f"   ‚úÖ Alacsony kock√°zat")

def main():
    """F≈ë f√ºggv√©ny"""
    analyzer = AdvancedLiveAnalyzer()

    print("üìä FEJLETT VAL√ìS IDEJ≈∞ ELEMZ≈ê")
    print("üìÖ", datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
    print("=" * 60)

    # Elemz√©s futtat√°sa
    result = analyzer.analyze_next_hours(4)

    if result['status'] == 'no_matches':
        print(f"‚ùå {result['message']}")
        return

    # Eredm√©nyek megjelen√≠t√©se
    print(f"\nüéØ ELEMZ√âS EREDM√âNYEK")
    print("=" * 30)
    print(f"üìä √ñsszes meccs: {result['total_matches']}")
    print(f"üí∞ Fogad√°si lehet≈ës√©gek: {result['betting_opportunities']}")
    print(f"üìà √Åtlagos bizalom: {result['summary']['avg_confidence']}")

    # Fogad√°si javaslatok
    if result['betting_suggestions']:
        analyzer.print_betting_recommendations(result['betting_suggestions'])

    # Ment√©s
    saved_file = analyzer.save_analysis_report(result)

    print(f"\nüí° TOV√ÅBBI L√âP√âSEK:")
    print(f"   1Ô∏è‚É£ Ellen≈ërizd a bookmaker odds-okat")
    print(f"   2Ô∏è‚É£ Csak kicsi t√©tekkel kezdj")
    print(f"   3Ô∏è‚É£ K√∂vesd nyomon az eredm√©nyeket")
    print(f"   4Ô∏è‚É£ Friss√≠tsd az elemz√©st 1 √≥r√°nk√©nt")

if __name__ == "__main__":
    main()
