#!/usr/bin/env python3
"""
üöÄ FUTBALL ADATELEMZ≈ê √âS EL≈êREJELZ≈ê RENDSZER

Integr√°lt pipeline:
1. PDF feldolgoz√°s √©s adatkinyer√©s
2. Adatb√°zis t√°rol√°s
3. ML modell tan√≠t√°s
4. Val√≥s idej≈± el≈ërejelz√©sek
5. Eredm√©nyek k√∂vet√©se
"""

import os
import sys
import json
import sqlite3
import pandas as pd
from datetime import datetime, timedelta
from enhanced_pdf_processor import EnhancedPDFProcessor
from football_prediction_model import FootballPredictionModel

class FootballAnalysisSystem:
    """
    Komplett futball elemz≈ë rendszer
    """

    def __init__(self, pdf_folder: str = "/home/bandi/Documents/code/2025/sp3/pdf"):
        self.pdf_folder = pdf_folder
        self.db_path = "football_master.db"

        # Komponensek
        self.pdf_processor = EnhancedPDFProcessor(self.db_path)
        self.ml_model = FootballPredictionModel(self.db_path)

        # Statisztik√°k
        self.stats = {
            'pdfs_processed': 0,
            'matches_extracted': 0,
            'predictions_made': 0,
            'model_accuracy': 0.0
        }

    def process_all_pdfs(self):
        """Minden PDF feldolgoz√°sa a mapp√°b√≥l"""
        print("üìÅ PDF-ek keres√©se...")

        if not os.path.exists(self.pdf_folder):
            print(f"‚ùå PDF mappa nem tal√°lhat√≥: {self.pdf_folder}")
            return False

        pdf_files = [f for f in os.listdir(self.pdf_folder) if f.endswith('.pdf')]

        if not pdf_files:
            print(f"‚ùå Nincs PDF f√°jl a mapp√°ban: {self.pdf_folder}")
            return False

        print(f"üìÑ {len(pdf_files)} PDF f√°jl tal√°lhat√≥")

        total_results = 0
        total_stats = 0
        total_upcoming = 0

        for pdf_file in pdf_files:
            pdf_path = os.path.join(self.pdf_folder, pdf_file)
            print(f"\nüîç Feldolgoz√°s: {pdf_file}")

            try:
                # PDF feldolgoz√°sa
                text_content = self.pdf_processor.extract_text_with_structure(pdf_path)

                if text_content:
                    # Eredm√©nyek kinyer√©se
                    initial_results = len(self.pdf_processor.match_results)
                    initial_stats = len(self.pdf_processor.team_stats)
                    initial_upcoming = len(self.pdf_processor.upcoming_matches)

                    self.pdf_processor.extract_match_results_from_text(text_content)
                    self.pdf_processor.extract_upcoming_matches_from_text(text_content)

                    # √öj adatok sz√°ma
                    new_results = len(self.pdf_processor.match_results) - initial_results
                    new_stats = len(self.pdf_processor.team_stats) - initial_stats
                    new_upcoming = len(self.pdf_processor.upcoming_matches) - initial_upcoming

                    total_results += new_results
                    total_stats += new_stats
                    total_upcoming += new_upcoming

                    print(f"‚úÖ {new_results} eredm√©ny, {new_stats} stat, {new_upcoming} j√∂v≈ëbeli meccs")

                    self.stats['pdfs_processed'] += 1

                else:
                    print(f"‚ùå Nem siker√ºlt kinyerni: {pdf_file}")

            except Exception as e:
                print(f"‚ùå Hiba {pdf_file} feldolgoz√°sakor: {e}")

        # Adatok ment√©se
        if total_results > 0 or total_stats > 0 or total_upcoming > 0:
            print(f"\nüíæ √ñsszes√≠tett adatok ment√©se...")
            self.pdf_processor.save_to_database()
            self.pdf_processor.export_to_csv()

            self.stats['matches_extracted'] = total_results

            print(f"‚úÖ √ñsszesen: {total_results} eredm√©ny, {total_stats} stat, {total_upcoming} j√∂v≈ëbeli meccs")
            return True
        else:
            print("‚ö†Ô∏è Nem tal√°ltunk √∫j adatokat")
            return False

    def train_prediction_model(self):
        """ML modell tan√≠t√°sa a √∂sszegy≈±jt√∂tt adatokon"""
        print("\nü§ñ ML MODELL TAN√çT√ÅSA")
        print("=" * 40)

        # Adatok bet√∂lt√©se
        self.ml_model.load_data_from_database()
        self.ml_model.load_additional_data()

        # Feature-√∂k l√©trehoz√°sa
        features = self.ml_model.create_features()

        if features is not None and len(features) >= 5:
            # Modell tan√≠t√°sa
            success = self.ml_model.train_models()

            if success:
                self.ml_model.save_model("football_master_model.pkl")
                self.stats['model_accuracy'] = self.ml_model.model_accuracy
                print(f"‚úÖ Modell tan√≠t√°sa sikeres: {self.ml_model.model_accuracy:.1%}")
                return True
            else:
                print("‚ùå Modell tan√≠t√°sa sikertelen")
                return False
        else:
            print("‚ùå Nincs elegend≈ë adat a modell tan√≠t√°s√°hoz")
            return False

    def predict_upcoming_matches(self):
        """J√∂v≈ëbeli meccsek el≈ërejelz√©se"""
        if self.ml_model.model_1x2 is None:
            print("‚ùå A modell m√©g nincs betan√≠tva")
            return

        print("\nüîÆ J√ñV≈êBELI MECCSEK EL≈êREJELZ√âSE")
        print("=" * 40)

        # Adatb√°zisb√≥l j√∂v≈ëbeli meccsek lek√©r√©se
        conn = sqlite3.connect(self.db_path)
        upcoming_df = pd.read_sql_query(
            """SELECT DISTINCT home_team, away_team, league, odds_home, odds_draw, odds_away
               FROM upcoming_matches
               WHERE odds_home IS NOT NULL
               ORDER BY home_team""",
            conn
        )
        conn.close()

        if upcoming_df.empty:
            print("üì≠ Nincs j√∂v≈ëbeli meccs odds-okkal")
            return

        predictions = []

        for _, match in upcoming_df.iterrows():
            prediction = self.ml_model.predict_match(
                match['home_team'],
                match['away_team'],
                match.get('league')
            )

            if prediction:
                # Odds √∂sszehasonl√≠t√°s
                actual_odds = {
                    'home': match.get('odds_home', 0),
                    'draw': match.get('odds_draw', 0),
                    'away': match.get('odds_away', 0)
                }

                # Value bet sz√°m√≠t√°s
                value_bets = self._calculate_value_bets(prediction['probabilities'], actual_odds)

                prediction_data = {
                    'match': f"{match['home_team']} vs {match['away_team']}",
                    'prediction': prediction['predicted_result'],
                    'confidence': prediction['confidence'],
                    'probabilities': prediction['probabilities'],
                    'actual_odds': actual_odds,
                    'value_bets': value_bets
                }

                predictions.append(prediction_data)
                self.stats['predictions_made'] += 1

                print(f"\nüí° {prediction_data['match']}")
                print(f"   üìä El≈ërejelz√©s: {prediction_data['prediction']} ({prediction_data['confidence']:.1%})")

                if value_bets:
                    print(f"   üí∞ Value bet-ek: {', '.join(value_bets)}")

                print("-" * 30)

        # El≈ërejelz√©sek ment√©se
        if predictions:
            self._save_predictions(predictions)
            print(f"‚úÖ {len(predictions)} el≈ërejelz√©s mentve")

    def _calculate_value_bets(self, predicted_probabilities, actual_odds):
        """Value bet-ek sz√°m√≠t√°sa"""
        value_bets = []

        # Implied probability vs predicted probability
        outcomes = [
            ('home_win', 'home', predicted_probabilities['home_win']),
            ('draw', 'draw', predicted_probabilities['draw']),
            ('away_win', 'away', predicted_probabilities['away_win'])
        ]

        for outcome_name, odds_key, predicted_prob in outcomes:
            actual_odd = actual_odds.get(odds_key, 0)

            if actual_odd > 1:  # Valid odds
                implied_prob = 1 / actual_odd

                # Value bet ha predicted > implied probability (+5% margin)
                if predicted_prob > implied_prob * 1.05:
                    value_percentage = ((predicted_prob / implied_prob) - 1) * 100
                    value_bets.append(f"{outcome_name} ({value_percentage:.1f}% value)")

        return value_bets

    def _save_predictions(self, predictions):
        """El≈ërejelz√©sek ment√©se JSON-ba"""
        prediction_data = {
            'generated_at': datetime.now().isoformat(),
            'model_accuracy': self.stats['model_accuracy'],
            'predictions': predictions
        }

        with open('predictions.json', 'w', encoding='utf-8') as f:
            json.dump(prediction_data, f, indent=2, ensure_ascii=False)

    def analyze_team_performance(self, team_name):
        """Csapat teljes√≠tm√©ny elemz√©se"""
        print(f"\nüìä CSAPAT ELEMZ√âS: {team_name}")
        print("=" * 40)

        conn = sqlite3.connect(self.db_path)

        # Meccs eredm√©nyek
        results_df = pd.read_sql_query(
            """SELECT * FROM match_results
               WHERE home_team = ? OR away_team = ?
               ORDER BY created_at DESC LIMIT 10""",
            conn, params=[team_name, team_name]
        )

        # Csapat statisztik√°k
        stats_df = pd.read_sql_query(
            """SELECT * FROM team_stats
               WHERE team_name = ?""",
            conn, params=[team_name]
        )

        conn.close()

        if results_df.empty:
            print(f"‚ùå Nincs adat {team_name} csapatr√≥l")
            return

        # Statisztik√°k sz√°m√≠t√°sa
        total_games = len(results_df)
        wins = 0
        draws = 0
        losses = 0
        goals_for = 0
        goals_against = 0

        for _, match in results_df.iterrows():
            home_score = match['home_score']
            away_score = match['away_score']

            if match['home_team'] == team_name:
                goals_for += home_score
                goals_against += away_score

                if home_score > away_score:
                    wins += 1
                elif home_score < away_score:
                    losses += 1
                else:
                    draws += 1
            else:
                goals_for += away_score
                goals_against += home_score

                if away_score > home_score:
                    wins += 1
                elif away_score < home_score:
                    losses += 1
                else:
                    draws += 1

        # Eredm√©nyek ki√≠r√°sa
        print(f"üèÜ Meccsek: {total_games}")
        print(f"‚úÖ Gy≈ëzelmek: {wins} ({wins/total_games*100:.1f}%)")
        print(f"ü§ù D√∂ntetlenek: {draws} ({draws/total_games*100:.1f}%)")
        print(f"‚ùå Veres√©gek: {losses} ({losses/total_games*100:.1f}%)")
        print(f"‚öΩ G√≥lok: {goals_for}:{goals_against} ({goals_for/total_games:.1f} g√≥l/meccs)")

        if not stats_df.empty:
            stat = stats_df.iloc[0]
            print(f"üìà Bajnoki poz√≠ci√≥: {stat.get('position', 'N/A')}")
            print(f"üèÜ Pontok: {stat.get('points', 'N/A')}")

    def generate_summary_report(self):
        """√ñsszefoglal√≥ jelent√©s gener√°l√°sa"""
        print("\nüìã √ñSSZEFOGLAL√ì JELENT√âS")
        print("=" * 50)

        # Adatb√°zis statisztik√°k
        conn = sqlite3.connect(self.db_path)

        results_count = pd.read_sql_query("SELECT COUNT(*) as count FROM match_results", conn).iloc[0]['count']
        teams_count = pd.read_sql_query("SELECT COUNT(DISTINCT team_name) as count FROM team_stats", conn).iloc[0]['count']
        leagues_count = pd.read_sql_query("SELECT COUNT(DISTINCT league) as count FROM team_stats", conn).iloc[0]['count']
        upcoming_count = pd.read_sql_query("SELECT COUNT(*) as count FROM upcoming_matches WHERE odds_home IS NOT NULL", conn).iloc[0]['count']

        conn.close()

        # Jelent√©s
        print(f"üìÑ Feldolgozott PDF-ek: {self.stats['pdfs_processed']}")
        print(f"‚öΩ Meccs eredm√©nyek: {results_count}")
        print(f"üë• K√ºl√∂nb√∂z≈ë csapatok: {teams_count}")
        print(f"üèüÔ∏è K√ºl√∂nb√∂z≈ë lig√°k: {leagues_count}")
        print(f"üîÆ J√∂v≈ëbeli meccsek: {upcoming_count}")
        print(f"ü§ñ Modell pontoss√°g: {self.stats['model_accuracy']:.1%}")
        print(f"üìä K√©sz√≠tett el≈ërejelz√©sek: {self.stats['predictions_made']}")

        # F√°jlok list√°ja
        print(f"\nüìÅ Gener√°lt f√°jlok:")
        files_to_check = [
            'football_master.db',
            'football_master_model.pkl',
            'predictions.json',
            'match_results.csv',
            'team_stats.csv',
            'upcoming_matches.csv'
        ]

        for file_name in files_to_check:
            if os.path.exists(file_name):
                size = os.path.getsize(file_name)
                print(f"   ‚úÖ {file_name} ({size:,} bytes)")
            else:
                print(f"   ‚ùå {file_name} (nem l√©tezik)")

def main():
    """F≈ëprogram"""
    print("üöÄ FUTBALL ADATELEMZ≈ê √âS EL≈êREJELZ≈ê RENDSZER")
    print("=" * 60)

    # Rendszer inicializ√°l√°sa
    system = FootballAnalysisSystem()

    # 1. PDF-ek feldolgoz√°sa
    print("\n1Ô∏è‚É£ PDF FELDOLGOZ√ÅS")
    pdf_success = system.process_all_pdfs()

    if pdf_success:
        # 2. ML modell tan√≠t√°sa
        print("\n2Ô∏è‚É£ ML MODELL TAN√çT√ÅSA")
        model_success = system.train_prediction_model()

        if model_success:
            # 3. El≈ërejelz√©sek k√©sz√≠t√©se
            print("\n3Ô∏è‚É£ EL≈êREJELZ√âSEK")
            system.predict_upcoming_matches()

            # 4. Csapat elemz√©sek (p√©ld√°k)
            print("\n4Ô∏è‚É£ CSAPAT ELEMZ√âSEK")
            example_teams = ["Dortmund", "Columbus", "Helsingborg"]

            for team in example_teams:
                system.analyze_team_performance(team)

        # 5. √ñsszefoglal√≥ jelent√©s
        print("\n5Ô∏è‚É£ √ñSSZEFOGLAL√ì")
        system.generate_summary_report()

        print("\n‚úÖ RENDSZER ELEMZ√âS BEFEJEZVE!")
        print("üìä R√©szletes adatok: football_master.db")
        print("ü§ñ Modell: football_master_model.pkl")
        print("üîÆ El≈ërejelz√©sek: predictions.json")

    else:
        print("‚ùå PDF feldolgoz√°s sikertelen, nem folytathatjuk")

if __name__ == "__main__":
    main()
